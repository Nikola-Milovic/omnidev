import { afterEach, beforeEach, describe, expect, test } from "bun:test";
import { existsSync, readFileSync, rmSync } from "node:fs";
import { parse } from "smol-toml";
import { tmpdir } from "@omnidev-ai/core/test-utils";
import type { LoadedCapability, McpConfig, SyncBundle } from "@omnidev-ai/core";
import { buildCodexMcpConfig, CodexTomlWriter } from "./toml.js";

describe("CodexTomlWriter", () => {
	let testDir: string;
	let originalCwd: string;

	beforeEach(() => {
		originalCwd = process.cwd();
		testDir = tmpdir("codex-toml-writer-");
		process.chdir(testDir);
	});

	afterEach(() => {
		process.chdir(originalCwd);
		if (existsSync(testDir)) {
			rmSync(testDir, { recursive: true, force: true });
		}
	});

	function createCapability(id: string, mcp?: McpConfig): LoadedCapability {
		const config: LoadedCapability["config"] = {
			capability: {
				id,
				name: id,
				version: "1.0.0",
				description: `Test capability ${id}`,
			},
		};
		if (mcp) {
			config.mcp = mcp;
		}
		return {
			id,
			path: `/fake/path/${id}`,
			config,
			skills: [],
			rules: [],
			docs: [],
			subagents: [],
			commands: [],
			exports: {},
		};
	}

	function createBundle(capabilities: LoadedCapability[]): SyncBundle {
		return {
			capabilities,
			skills: [],
			rules: [],
			docs: [],
			commands: [],
			subagents: [],
			instructionsContent: "",
		};
	}

	test("has correct id", () => {
		expect(CodexTomlWriter.id).toBe("codex-toml");
	});

	test("writes MCPs with stdio transport", async () => {
		const mcp: McpConfig = {
			command: "npx",
			args: ["-y", "@upstash/context7-mcp"],
		};
		const bundle = createBundle([createCapability("context7", mcp)]);

		const result = await CodexTomlWriter.write(bundle, {
			outputPath: ".codex/config.toml",
			projectRoot: testDir,
		});

		expect(result.filesWritten).toEqual([".codex/config.toml"]);
		expect(existsSync(`${testDir}/.codex/config.toml`)).toBe(true);

		const content = readFileSync(`${testDir}/.codex/config.toml`, "utf-8");
		expect(content).toContain("# Generated by OmniDev");

		const parsed = parse(content) as {
			mcp_servers: Record<string, Record<string, unknown>>;
		};

		expect(parsed.mcp_servers["context7"]).toBeDefined();
		expect(parsed.mcp_servers["context7"]["command"]).toBe("npx");
		expect(parsed.mcp_servers["context7"]["args"]).toEqual(["-y", "@upstash/context7-mcp"]);
	});

	test("writes MCPs with env and cwd", async () => {
		const mcp: McpConfig = {
			command: "node",
			args: ["server.js"],
			env: { DEBUG: "true", API_KEY: "secret" },
			cwd: "/path/to/server",
		};
		const bundle = createBundle([createCapability("my-server", mcp)]);

		const result = await CodexTomlWriter.write(bundle, {
			outputPath: ".codex/config.toml",
			projectRoot: testDir,
		});

		expect(result.filesWritten).toEqual([".codex/config.toml"]);

		const content = readFileSync(`${testDir}/.codex/config.toml`, "utf-8");
		const parsed = parse(content) as {
			mcp_servers: Record<string, Record<string, unknown>>;
		};

		expect(parsed.mcp_servers["my-server"]).toBeDefined();
		expect(parsed.mcp_servers["my-server"]["command"]).toBe("node");
		expect(parsed.mcp_servers["my-server"]["args"]).toEqual(["server.js"]);
		expect(parsed.mcp_servers["my-server"]["env"]).toEqual({
			DEBUG: "true",
			API_KEY: "secret",
		});
		expect(parsed.mcp_servers["my-server"]["cwd"]).toBe("/path/to/server");
	});

	test("writes MCPs with http transport", async () => {
		const mcp: McpConfig = {
			transport: "http",
			url: "https://api.example.com/mcp",
			headers: { Authorization: "Bearer token123" },
		};
		const bundle = createBundle([createCapability("remote-mcp", mcp)]);

		const result = await CodexTomlWriter.write(bundle, {
			outputPath: ".codex/config.toml",
			projectRoot: testDir,
		});

		expect(result.filesWritten).toEqual([".codex/config.toml"]);

		const content = readFileSync(`${testDir}/.codex/config.toml`, "utf-8");
		const parsed = parse(content) as {
			mcp_servers: Record<string, Record<string, unknown>>;
		};

		expect(parsed.mcp_servers["remote-mcp"]).toBeDefined();
		expect(parsed.mcp_servers["remote-mcp"]["url"]).toBe("https://api.example.com/mcp");
		expect(parsed.mcp_servers["remote-mcp"]["http_headers"]).toEqual({
			Authorization: "Bearer token123",
		});
		// Should not have stdio-specific fields
		expect(parsed.mcp_servers["remote-mcp"]["command"]).toBeUndefined();
	});

	test("skips SSE transport with warning", async () => {
		const originalWarn = console.warn;
		const warnings: string[] = [];
		console.warn = (...args: unknown[]) => warnings.push(args.join(" "));

		try {
			const mcp: McpConfig = {
				transport: "sse",
				url: "https://api.example.com/sse",
			};
			const bundle = createBundle([createCapability("sse-mcp", mcp)]);

			const result = await CodexTomlWriter.write(bundle, {
				outputPath: ".codex/config.toml",
				projectRoot: testDir,
			});

			// Should not write file since only MCP was skipped
			expect(result.filesWritten).toEqual([]);
			expect(existsSync(`${testDir}/.codex/config.toml`)).toBe(false);

			// Should have logged a warning
			expect(warnings.some((w) => w.includes("SSE transport is not supported"))).toBe(true);
		} finally {
			console.warn = originalWarn;
		}
	});

	test("handles multiple MCPs", async () => {
		const bundle = createBundle([
			createCapability("mcp-one", {
				command: "npx",
				args: ["-y", "@mcp/one"],
			}),
			createCapability("mcp-two", {
				command: "npx",
				args: ["-y", "@mcp/two"],
				env: { MODE: "production" },
			}),
			createCapability("mcp-http", {
				transport: "http",
				url: "https://mcp.example.com",
			}),
		]);

		const result = await CodexTomlWriter.write(bundle, {
			outputPath: ".codex/config.toml",
			projectRoot: testDir,
		});

		expect(result.filesWritten).toEqual([".codex/config.toml"]);

		const content = readFileSync(`${testDir}/.codex/config.toml`, "utf-8");
		const parsed = parse(content) as {
			mcp_servers: Record<string, Record<string, unknown>>;
		};

		expect(Object.keys(parsed.mcp_servers)).toHaveLength(3);
		expect(parsed.mcp_servers["mcp-one"]).toBeDefined();
		expect(parsed.mcp_servers["mcp-two"]).toBeDefined();
		expect(parsed.mcp_servers["mcp-http"]).toBeDefined();
	});

	test("returns empty array when no MCPs", async () => {
		const bundle = createBundle([
			createCapability("no-mcp-cap"), // No MCP config
		]);

		const result = await CodexTomlWriter.write(bundle, {
			outputPath: ".codex/config.toml",
			projectRoot: testDir,
		});

		expect(result.filesWritten).toEqual([]);
		expect(existsSync(`${testDir}/.codex/config.toml`)).toBe(false);
	});

	test("returns empty array when bundle has no capabilities", async () => {
		const bundle = createBundle([]);

		const result = await CodexTomlWriter.write(bundle, {
			outputPath: ".codex/config.toml",
			projectRoot: testDir,
		});

		expect(result.filesWritten).toEqual([]);
	});

	test("creates parent directory if needed", async () => {
		const mcp: McpConfig = {
			command: "node",
			args: ["server.js"],
		};
		const bundle = createBundle([createCapability("test-mcp", mcp)]);

		// .codex directory doesn't exist yet
		expect(existsSync(`${testDir}/.codex`)).toBe(false);

		await CodexTomlWriter.write(bundle, {
			outputPath: ".codex/config.toml",
			projectRoot: testDir,
		});

		expect(existsSync(`${testDir}/.codex`)).toBe(true);
		expect(existsSync(`${testDir}/.codex/config.toml`)).toBe(true);
	});

	test("regenerates file on re-sync (replaces previous content)", async () => {
		// First sync
		const bundle1 = createBundle([
			createCapability("old-mcp", {
				command: "old-command",
				args: ["old-arg"],
			}),
		]);

		await CodexTomlWriter.write(bundle1, {
			outputPath: ".codex/config.toml",
			projectRoot: testDir,
		});

		const content1 = readFileSync(`${testDir}/.codex/config.toml`, "utf-8");
		expect(content1).toContain("old-mcp");
		expect(content1).toContain("old-command");

		// Second sync with different MCP
		const bundle2 = createBundle([
			createCapability("new-mcp", {
				command: "new-command",
				args: ["new-arg"],
			}),
		]);

		await CodexTomlWriter.write(bundle2, {
			outputPath: ".codex/config.toml",
			projectRoot: testDir,
		});

		const content2 = readFileSync(`${testDir}/.codex/config.toml`, "utf-8");
		// Old content should be gone
		expect(content2).not.toContain("old-mcp");
		expect(content2).not.toContain("old-command");
		// New content should be present
		expect(content2).toContain("new-mcp");
		expect(content2).toContain("new-command");
	});

	test("omits empty args and env", async () => {
		const mcp: McpConfig = {
			command: "simple-server",
			args: [], // Empty array
			env: {}, // Empty object
		};
		const bundle = createBundle([createCapability("simple", mcp)]);

		await CodexTomlWriter.write(bundle, {
			outputPath: ".codex/config.toml",
			projectRoot: testDir,
		});

		const content = readFileSync(`${testDir}/.codex/config.toml`, "utf-8");
		const parsed = parse(content) as {
			mcp_servers: Record<string, Record<string, unknown>>;
		};

		// Should have command but not empty arrays/objects
		expect(parsed.mcp_servers["simple"]["command"]).toBe("simple-server");
		expect(parsed.mcp_servers["simple"]["args"]).toBeUndefined();
		expect(parsed.mcp_servers["simple"]["env"]).toBeUndefined();
	});
});

describe("buildCodexMcpConfig", () => {
	test("converts stdio transport correctly", () => {
		const mcp: McpConfig = {
			command: "npx",
			args: ["-y", "@playwright/mcp"],
			env: { DEBUG: "true" },
			cwd: "/project",
		};

		const result = buildCodexMcpConfig("test", mcp);

		expect(result).toEqual({
			command: "npx",
			args: ["-y", "@playwright/mcp"],
			env: { DEBUG: "true" },
			cwd: "/project",
		});
	});

	test("converts http transport correctly", () => {
		const mcp: McpConfig = {
			transport: "http",
			url: "https://api.example.com/mcp",
			headers: { Authorization: "Bearer token" },
		};

		const result = buildCodexMcpConfig("test", mcp);

		expect(result).toEqual({
			url: "https://api.example.com/mcp",
			http_headers: { Authorization: "Bearer token" },
		});
	});

	test("returns null for sse transport", () => {
		const originalWarn = console.warn;
		console.warn = () => {}; // Suppress warning

		try {
			const mcp: McpConfig = {
				transport: "sse",
				url: "https://api.example.com/sse",
			};

			const result = buildCodexMcpConfig("test", mcp);

			expect(result).toBeNull();
		} finally {
			console.warn = originalWarn;
		}
	});

	test("uses stdio as default transport", () => {
		const mcp: McpConfig = {
			command: "server",
			// No transport specified
		};

		const result = buildCodexMcpConfig("test", mcp);

		expect(result?.command).toBe("server");
	});
});
