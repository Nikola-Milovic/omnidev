import { mkdir, writeFile } from "node:fs/promises";
import { dirname, join } from "node:path";
import type { McpConfig, SyncBundle } from "@omnidev-ai/core";
import { stringify } from "smol-toml";
import type { FileWriter, WriterContext, WriterResult } from "../generic/types.js";

/**
 * Codex MCP server config format (for `.codex/config.toml`)
 */
interface CodexMcpServerConfig {
	/** Command to run (stdio transport) */
	command?: string;
	/** Command arguments (stdio transport) */
	args?: string[];
	/** Environment variables (stdio transport) */
	env?: Record<string, string>;
	/** Working directory (stdio transport) */
	cwd?: string;
	/** URL for remote servers (http transport) */
	url?: string;
	/** HTTP headers for authentication (http transport) */
	http_headers?: Record<string, string>;
}

/**
 * Codex config.toml structure
 */
interface CodexConfig {
	mcp_servers?: Record<string, CodexMcpServerConfig>;
}

/**
 * File header for generated config
 */
const FILE_HEADER = `# Generated by OmniDev - DO NOT EDIT
# Run \`omnidev sync\` to regenerate

`;

/**
 * Convert OmniDev McpConfig to Codex format.
 * Returns null if the transport is not supported.
 */
export function buildCodexMcpConfig(id: string, mcp: McpConfig): CodexMcpServerConfig | null {
	const transport = mcp.transport ?? "stdio";

	// SSE transport is not supported by Codex
	if (transport === "sse") {
		console.warn(`  Warning: Skipping MCP "${id}" - SSE transport is not supported by Codex`);
		return null;
	}

	const config: CodexMcpServerConfig = {};

	if (transport === "http") {
		// HTTP transport - use url and http_headers
		if (mcp.url) {
			config.url = mcp.url;
		}
		if (mcp.headers && Object.keys(mcp.headers).length > 0) {
			config.http_headers = mcp.headers;
		}
	} else {
		// stdio transport - use command, args, env, cwd
		if (mcp.command) {
			config.command = mcp.command;
		}
		if (mcp.args && mcp.args.length > 0) {
			config.args = mcp.args;
		}
		if (mcp.env && Object.keys(mcp.env).length > 0) {
			config.env = mcp.env;
		}
		if (mcp.cwd) {
			config.cwd = mcp.cwd;
		}
	}

	return config;
}

/**
 * Collect all MCPs from the sync bundle's capabilities.
 */
function collectMcps(bundle: SyncBundle): Map<string, McpConfig> {
	const mcps = new Map<string, McpConfig>();

	for (const capability of bundle.capabilities) {
		if (capability.config.mcp) {
			// Use capability ID as the MCP server ID
			mcps.set(capability.id, capability.config.mcp);
		}
	}

	return mcps;
}

/**
 * Writer for Codex config.toml file.
 *
 * Writes MCP server configurations from the sync bundle to `.codex/config.toml`.
 * OmniDev fully manages this file and regenerates it on each sync.
 *
 * Used by codex (.codex/config.toml).
 */
export const CodexTomlWriter: FileWriter = {
	id: "codex-toml",

	async write(bundle: SyncBundle, ctx: WriterContext): Promise<WriterResult> {
		const mcps = collectMcps(bundle);

		// If no MCPs, don't write the file
		if (mcps.size === 0) {
			return { filesWritten: [] };
		}

		const configPath = join(ctx.projectRoot, ctx.outputPath);

		// Ensure parent directory exists
		const parentDir = dirname(configPath);
		await mkdir(parentDir, { recursive: true });

		// Build the Codex config
		const mcpServers: Record<string, CodexMcpServerConfig> = {};

		for (const [id, mcp] of mcps) {
			const converted = buildCodexMcpConfig(id, mcp);
			if (converted) {
				mcpServers[id] = converted;
			}
		}

		// If all MCPs were skipped (e.g., all SSE), don't write the file
		if (Object.keys(mcpServers).length === 0) {
			return { filesWritten: [] };
		}

		const codexConfig: CodexConfig = {
			mcp_servers: mcpServers,
		};

		// Generate TOML content
		const tomlContent = FILE_HEADER + stringify(codexConfig);

		// Write the file
		await writeFile(configPath, tomlContent, "utf-8");

		return {
			filesWritten: [ctx.outputPath],
		};
	},
};
